#!/usr/bin/perl

use File::Find;
use strict;
my %opts =
    (
    );

LocalGetOptions(\%opts,
		['GUI:otherargs', '[input-directory] [output-directory]'],		
    );

my $inputDirectory = $ARGV[0];
my $outputDirectory = $ARGV[1];

if (!defined($inputDirectory) || !defined($outputDirectory)) {
    print STDERR "Both an input and output directory are required\n";
    exit 1;
}

find(\&convert_file, $inputDirectory);

sub convert_file {
    if ($File::Find::name =~ /\.cer/i) {
	# process it...
    }
}

######################################################################
# Getopt bootstrapping
#
sub LocalGetOptions {
    if (eval {require Getopt::GUI::Long;}) {
	import Getopt::GUI::Long;
	# optional configure call
	Getopt::GUI::Long::Configure(qw(display_help no_gui no_ignore_case allow_zero));
	return GetOptions(@_);
    }
    require Getopt::Long;
    import Getopt::Long;
    # optional configure call
    Getopt::Long::Configure(qw(auto_help no_ignore_case));
    GetOptions(LocalOptionsMap(@_));
}

sub LocalOptionsMap {
    my ($st, $cb, @opts) = ((ref($_[0]) eq 'HASH')
			    ? (1, 1, $_[0]) : (0, 2));
    for (my $i = $st; $i <= $#_; $i += $cb) {
	if ($_[$i]) {
	    next if (ref($_[$i]) eq 'ARRAY' && $_[$i][0] =~ /^GUI:/);
	    push @opts, ((ref($_[$i]) eq 'ARRAY') ? $_[$i][0] : $_[$i]);
	    push @opts, $_[$i+1] if ($cb == 2);
	}
    }
    return @opts;
}

1;

=pod

=head1 NAME

bgpsec-create-hash-dir - creates a SKI-based hash directory

=head1 SYNOPSIS

bgpsec-create-hash-dir /path/to/rpki-authenticated-dir /path/to/hash-dir


